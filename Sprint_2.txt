PMS - Post Machine Solution (Piazza Answer Module)
AI - Analyse Information (Fetching + Analysing keywords)
Dust - Database Update Solution Table (Database update module) 
Ass - Access Stored Solutions (Database fetch data)

SHORT EXPLANATION:
	
	look at ModuleArchitecture first!
	
	Dust is used to update the database, by receiving its param from AI.
	
	Ass is used to retrieve/fetch appropriate solution to the set of param given by AI
	and then sends it to PMS
	
	PMS is used to send the found solution to piazza.
	
	AI is used to fetch data from piazza and analyses its keywords and then either sends
	them to Dust to update the database or Ass to fetch a solution. If more than one post
	is fetched it will solve it and send one set of ID + keywords at a time, ie STACK.
	
	Main initialises everything, ie creates all necessary modules for the bot to function
	and starts a while loop with TIME-CONSTRAINTS that decides when to fetch data and in 
	which sequence the modules should RUN(). We can put UI(if needed) here, to get all the
	necessary data from the user of the bot	


NOTE 1:

NUMBERS ARE INT!
SENTENCES/WORDS ARE STRING!


General Methods:

	//Methods that all modules NEED to have

	- run()
	- set_data(param)

Explanation - pseudo-code:

	run():
		if has_data:
			do something....	
			send results to next module	
			has_data = FALSE
			
		//READ (NOTE 2) 
		if has_unsendt_data:
			resend
			has_unsendt_data = FALSE
	
	set_data(param):
		if not has_data:
			my_var = param
			has_data = TRUE

Explanation - text:
	
	run(): 
		This is the methods used by MAIN's loop to activate each module, it checks if
		it has data(ie has_data = TRUE) and if it does, does what its supposed to do
		(different for each module) after having done its task, it sends its results 
		to the next module(if it has) then sets its variable has_data to False(simulating
		that it has no data)
	
	set_data(param):
		This method is used by the cross-communication(ie other modules, NOT main). This
		is basically the method that makes it possible to receive information from other 
		modules. This method servers both as both RECEIVING and SENDING. AI --> Dust
		AI uses method dust.set_data(param), AI is the sender, dust is the receiver.
		After "saving" the received data ie param(different for each module), it wil store
		it locally then set has_data = True(simulating that it has data)
					  	
--------------------
Param - Specification:
--------------------

Dust:
	- set_data(arr): // this is INPUT to module
		arr == [int, str, str, .... , str]
		exp: [161, "my", "balls", "are", "terribly", "itchy"]

	- no specific output, look at ModuleArchitecture


Ass:
	- set_data(arr): // this is INPUT to module
		arr == [str, str, ... , str]
		exp: ["I'm", "gonna", "die", "from", "itchiness"]
	
	- Pms.set_data(str/int): // This is OUTPUT from module
		// As seen from param, only send ONE(1) solution, ie highest one, others are "dont care"
		// if its a number then send as INT else STR(this only applies for later expansions)
		// NOTE: if "@161", remove "@" and send INT(161)


PMS: 
	- set_data(str/int): // This is INPUT to module
		same as stated above (ASS)
	
	- no specific output, look at ModuleArchitecture


AI: 	- No specific input
	
	- Ass.set_data(arr):
		specifications stated above.
	
	- Dust.set_data(arr)
		specifications stated above.
	
NOTE 2: 	
	The rest of the methods you need (java- private methods) are up to you to.
	ALL THE SPECIFIED METHODS are to be used with a check clause. If it fails to set
	the data(RECEIVER), it has to send a False back to the SENDER, so that info do not get lost.
	meaning that if a set_data fails, you have to store it somewhere to get resendt at a later
	RUN(). This also means that if a data has not been sendt, new data shall not be received.


						